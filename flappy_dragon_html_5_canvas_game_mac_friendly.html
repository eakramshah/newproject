<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Flappy Dragon</title>
  <style>
    :root {
      --bg: #0b1020;
      --fg: #e7f0ff;
      --accent: #7cfead;
      --dim: #607699;
      --pillar: #2b364e;
      --lava: #ff6a3d;
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0; height: 100%; background: radial-gradient(1200px 800px at 70% 20%, #141b35 0%, var(--bg) 60%);
      color: var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      user-select: none;
    }
    .wrap {
      display: grid; place-items: center; height: 100%; padding: 16px;
    }
    canvas { 
      background: transparent; 
      width: min(100%, 800px); height: auto; aspect-ratio: 3 / 4; 
      border-radius: 20px; box-shadow: 0 20px 60px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.06);
    }
    .hud {
      position: fixed; inset: 0; pointer-events: none; display: grid; place-items: center; padding: 16px;
      font-weight: 600; text-align: center;
    }
    .pill { background: rgba(255,255,255,.06); border: 1px solid rgba(255,255,255,.12); padding: 14px 18px; border-radius: 14px; backdrop-filter: blur(6px); }
    .title { font-size: clamp(20px, 4vw, 32px); letter-spacing: .5px; }
    .meta { margin-top: 10px; font-size: 14px; color: var(--dim); }
    .controls { margin-top: 14px; font-size: 14px; color: var(--accent) }
    .scorebar { position: fixed; top: 14px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; pointer-events: none; }
    .badge { background: rgba(0,0,0,.35); border: 1px solid rgba(255,255,255,.1); padding: 8px 12px; border-radius: 999px; font-size: 13px; }
    .btns { position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; }
    button { pointer-events: auto; cursor: pointer; padding: 10px 14px; border-radius: 12px; border: 1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.08); color: var(--fg); font-weight: 600; }
    button:hover { background: rgba(255,255,255,.12); }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="900" height="1200" aria-label="Flappy Dragon Game"></canvas>
  </div>

  <div class="scorebar">
    <div class="badge">Score: <span id="score">0</span></div>
    <div class="badge">Best: <span id="best">0</span></div>
    <div class="badge">Speed: <span id="spd">1.0x</span></div>
  </div>

  <div class="hud" id="hud">
    <div class="pill">
      <div class="title">üêâ Flappy Dragon</div>
      <div class="meta">Fly a tiny dragon through volcanic pillars. Avoid collisions, grab coins, and set a high score!</div>
      <div class="controls">Press <b>Space</b> ¬∑ <b>Click</b> ¬∑ <b>Tap</b> to flap. Press <b>P</b> to pause.</div>
      <div class="meta" style="margin-top:12px">Press any key or click to start.</div>
    </div>
  </div>

  <div class="btns">
    <button id="restart" title="Restart">‚Üª Restart</button>
    <button id="pause" title="Pause/Resume">‚èØ Pause</button>
  </div>

  <script>
  (function(){
    const canvas = document.getElementById('game');
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const ctx = canvas.getContext('2d');
    // Auto-scale for HiDPI
    function resize() {
      const cssW = Math.min(window.innerWidth - 32, 800);
      const cssH = cssW * 4/3; // aspect
      canvas.style.width = cssW + 'px';
      canvas.style.height = cssH + 'px';
      canvas.width = Math.floor(cssW * dpr);
      canvas.height = Math.floor(cssH * dpr);
    }
    resize();
    window.addEventListener('resize', resize);

    // UI elements
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const spdEl = document.getElementById('spd');
    const hud = document.getElementById('hud');
    const restartBtn = document.getElementById('restart');
    const pauseBtn = document.getElementById('pause');

    // Game constants
    const W = () => canvas.width;
    const H = () => canvas.height;
    const GRAVITY = 0.0016; // px/ms^2 (scaled by dpr)
    const FLAP = -0.55;     // impulse velocity
    const DRAGON_R = 22 * dpr;
    const PIPE_W = 120 * dpr;
    const GAP_MIN = 260 * dpr;
    const GAP_MAX = 340 * dpr;
    const PIPE_SPACING = 520 * dpr; // horizontal distance between pipes
    const COIN_R = 10 * dpr;

    let state = 'ready'; // 'ready' | 'playing' | 'dead' | 'paused'
    let score = 0;
    let best = Number(localStorage.getItem('flappy-dragon-best') || 0);
    bestEl.textContent = best;

    const dragon = { x: 0, y: 0, vy: 0, rot: 0, flapPhase: 0 };
    let pipes = [];
    let coins = [];
    let t0 = performance.now();
    let speed = 0.35; // px/ms base speed

    function reset() {
      score = 0; scoreEl.textContent = score;
      speed = 0.35; spdEl.textContent = speed.toFixed(1) + 'x';
      dragon.x = W()*0.28; dragon.y = H()*0.45; dragon.vy = 0; dragon.rot = 0; dragon.flapPhase = 0;
      pipes = [];
      coins = [];
      // seed a few pipes
      let x = W()*1.1;
      for (let i=0;i<5;i++) { pipes.push(makePipe(x)); if (i%2===0) coins.push(makeCoinNearPipe(pipes[pipes.length-1])); x += PIPE_SPACING; }
    }

    function makePipe(x) {
      const gap = rnd(GAP_MIN, GAP_MAX);
      const topH = rnd(80*dpr, H()-gap-80*dpr);
      return { x, topH, gap, passed:false };
    }
    function makeCoinNearPipe(pipe) {
      const cx = pipe.x + PIPE_W/2; // center near the middle of pillar
      const cy = pipe.topH + pipe.gap/2 + rnd(-pipe.gap*0.25, pipe.gap*0.25);
      return { x: cx, y: cy, r: COIN_R, taken:false };
    }
    function rnd(a,b){ return a + Math.random()*(b-a); }

    // Input
    function flap(){ if(state==='playing'){ dragon.vy = FLAP; dragon.flapPhase = 1; } else if(state==='ready'){ state='playing'; hud.style.display='none'; } else if (state==='dead') { reset(); state='playing'; hud.style.display='none'; } }
    window.addEventListener('keydown', (e)=>{
      if (e.code==='Space') { e.preventDefault(); flap(); }
      if (e.code==='KeyP') { togglePause(); }
    });
    canvas.addEventListener('mousedown', flap);
    canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); flap(); }, {passive:false});

    restartBtn.addEventListener('click', ()=>{ reset(); state='ready'; hud.style.display='grid'; });
    pauseBtn.addEventListener('click', togglePause);

    function togglePause(){
      if (state==='playing') state='paused';
      else if (state==='paused') { state='playing'; t0 = performance.now(); }
    }

    // Drawing helpers
    function drawDragon() {
      const {x,y} = dragon;
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(dragon.rot);
      // body
      const bodyR = DRAGON_R;
      const wingSpan = bodyR*1.6;
      const flap = Math.sin(dragon.flapPhase*6) * (bodyR*0.6);
      // body circle
      circle(0,0, bodyR, '#36e3ff', '#0a2430');
      // belly
      circle(bodyR*0.25, bodyR*0.2, bodyR*0.55, '#7cfead88', null);
      // eye
      circle(bodyR*0.35, -bodyR*0.2, bodyR*0.15, '#fff', '#000');
      circle(bodyR*0.45, -bodyR*0.2, bodyR*0.07, '#000', null);
      // wing
      ctx.beginPath();
      ctx.moveTo(-bodyR*0.2, -bodyR*0.2);
      ctx.quadraticCurveTo(-wingSpan*0.2, -wingSpan*0.6, -wingSpan, -flap);
      ctx.quadraticCurveTo(-wingSpan*0.2, 0, -bodyR*0.2, bodyR*0.2);
      ctx.closePath();
      ctx.fillStyle = '#7cfead';
      ctx.globalAlpha = 0.9; ctx.fill(); ctx.globalAlpha = 1;
      // flame when diving fast
      if (dragon.vy > 0.55) {
        ctx.beginPath();
        ctx.moveTo(-bodyR*0.9, bodyR*0.15);
        ctx.quadraticCurveTo(-bodyR*1.4, bodyR*0.1, -bodyR*1.9, 0);
        ctx.quadraticCurveTo(-bodyR*1.2, -bodyR*0.1, -bodyR*0.9, -bodyR*0.15);
        ctx.fillStyle = '#ffef5a'; ctx.fill();
        ctx.beginPath();
        ctx.moveTo(-bodyR*0.9, bodyR*0.12);
        ctx.quadraticCurveTo(-bodyR*1.2, 0, -bodyR*1.5, 0);
        ctx.quadraticCurveTo(-bodyR*1.1, 0, -bodyR*0.9, -bodyR*0.12);
        ctx.fillStyle = '#ff6a3d'; ctx.fill();
      }
      ctx.restore();
    }

    function circle(x,y,r,fill,stroke){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); if(fill){ ctx.fillStyle=fill; ctx.fill(); } if(stroke){ ctx.strokeStyle=stroke; ctx.lineWidth = Math.max(1, r*0.08); ctx.stroke(); } }

    function drawPipe(p) {
      // top pipe
      ctx.fillStyle = '#1a2235';
      ctx.fillRect(p.x, 0, PIPE_W, p.topH);
      // top cap
      ctx.fillStyle = '#2b364e';
      ctx.fillRect(p.x-6*dpr, p.topH-16*dpr, PIPE_W+12*dpr, 16*dpr);
      // bottom pipe
      const bottomY = p.topH + p.gap;
      ctx.fillStyle = '#1a2235';
      ctx.fillRect(p.x, bottomY, PIPE_W, H() - bottomY);
      // bottom cap
      ctx.fillStyle = '#2b364e';
      ctx.fillRect(p.x-6*dpr, bottomY, PIPE_W+12*dpr, 16*dpr);
      // lava at ground
      ctx.fillStyle = 'rgba(255,106,61,.15)';
      ctx.fillRect(0, H()-20*dpr, W(), 20*dpr);
    }

    function drawCoin(c){
      const grd = ctx.createRadialGradient(c.x - c.r*0.3, c.y - c.r*0.3, c.r*0.2, c.x, c.y, c.r);
      grd.addColorStop(0, '#fff8cc');
      grd.addColorStop(1, '#ffd447');
      ctx.fillStyle = grd;
      circle(c.x, c.y, c.r, grd, '#e0aa00');
      // inner mark
      ctx.beginPath();
      ctx.arc(c.x, c.y, c.r*0.55, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(0,0,0,.25)'; ctx.lineWidth = Math.max(1, c.r*0.18); ctx.stroke();
    }

    function AABBcircle(px, py, pw, ph, cx, cy, cr){
      const closestX = Math.max(px, Math.min(cx, px + pw));
      const closestY = Math.max(py, Math.min(cy, py + ph));
      const dx = cx - closestX, dy = cy - closestY; return (dx*dx + dy*dy) <= cr*cr;
    }

    function update(dt){
      if (state !== 'playing') return;
      // difficulty ramp
      speed += dt * 0.000003; // slow ramp
      spdEl.textContent = (1 + (speed-0.35)/0.15).toFixed(1) + 'x';

      // dragon physics
      dragon.vy += GRAVITY * dt * dpr;
      dragon.y += dragon.vy * dt * 1.2 * dpr;
      dragon.rot = Math.max(-0.5, Math.min(1.0, dragon.vy*0.35));
      dragon.flapPhase += dt*0.006 + (dragon.vy<0 ? 0.01 : 0);

      // pipes
      for (const p of pipes){ p.x -= speed * dt * dpr * 0.9; }
      if (pipes.length && pipes[0].x + PIPE_W < -20*dpr) {
        pipes.shift();
        // add a new one at the end
        const lastX = pipes[pipes.length-1].x; const np = makePipe(lastX + PIPE_SPACING); pipes.push(np);
        // add a coin for every other pipe
        if (Math.random() < 0.6) coins.push(makeCoinNearPipe(np));
      }

      // coins
      for (const c of coins){ c.x -= speed * dt * dpr * 0.9; }
      if (coins.length && coins[0].x + COIN_R < -20*dpr) coins.shift();

      // scoring (passing pipes)
      for (const p of pipes){
        if (!p.passed && dragon.x > p.x + PIPE_W) { p.passed = true; score++; scoreEl.textContent = score; }
      }

      // collisions
      // ground / ceiling
      if (dragon.y > H()-DRAGON_R-20*dpr || dragon.y < DRAGON_R) return die();
      // pipes collision
      for (const p of pipes){
        if (AABBcircle(p.x, 0, PIPE_W, p.topH, dragon.x, dragon.y, DRAGON_R) ||
            AABBcircle(p.x, p.topH+p.gap, PIPE_W, H()-(p.topH+p.gap), dragon.x, dragon.y, DRAGON_R)) {
          return die();
        }
      }
      // coin pickup
      for (const c of coins){
        if (!c.taken) {
          const dx = dragon.x - c.x, dy = dragon.y - c.y;
          if (dx*dx + dy*dy < (DRAGON_R + c.r)*(DRAGON_R + c.r)) {
            c.taken = true; score += 3; scoreEl.textContent = score; // coins give +3
          }
        }
      }
    }

    function die(){
      state = 'dead';
      best = Math.max(best, score); bestEl.textContent = best; localStorage.setItem('flappy-dragon-best', best);
      showHUD();
    }

    function showHUD(){
      hud.style.display = 'grid';
      hud.querySelector('.title').textContent = state==='dead' ? 'Game Over ‚Äî Flappy Dragon' : 'üêâ Flappy Dragon';
      hud.querySelector('.meta').innerHTML = state==='dead' ? `Score: <b>${score}</b> ¬∑ Best: <b>${best}</b>` : 'Fly a tiny dragon through volcanic pillars. Avoid collisions, grab coins, and set a high score!';
    }

    function render(){
      // sky
      ctx.clearRect(0,0,W(),H());
      // parallax mountains
      drawMountains();
      // pipes
      for (const p of pipes) drawPipe(p);
      // coins
      for (const c of coins) if(!c.taken) drawCoin(c);
      // dragon
      drawDragon();
      // foreground glow line
      ctx.fillStyle = 'rgba(255,255,255,.06)';
      ctx.fillRect(0, H()-40*dpr, W(), 2*dpr);
    }

    function drawMountains(){
      const t = performance.now()*0.0001;
      const baseY = H()*0.75;
      ctx.save();
      ctx.translate(0, baseY);
      for (let layer=0; layer<3; layer++){
        const amp = (3-layer) * 10 * dpr;
        const step = (layer+1) * 6 * dpr;
        ctx.beginPath();
        ctx.moveTo(0,0);
        for (let x=0; x<=W(); x+=step){
          const y = Math.sin((x*0.002 + t* (layer+1))) * amp - layer*30*dpr;
          ctx.lineTo(x, y);
        }
        ctx.lineTo(W(), H()); ctx.lineTo(0,H());
        ctx.closePath();
        ctx.fillStyle = `rgba(124,254,173,${0.05 + layer*0.05})`;
        ctx.fill();
      }
      ctx.restore();
    }

    function loop(now){
      const dt = now - t0; t0 = now;
      if (state==='playing') update(dt);
      render();
      requestAnimationFrame(loop);
    }

    // boot
    reset();
    showHUD();
    requestAnimationFrame((t)=>{ t0 = t; requestAnimationFrame(loop); });

  })();
  </script>
</body>
</html>
